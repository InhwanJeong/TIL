# 고성능 파이썬
- 쉽게 개발하는 것과 원하는 만큼의 실행속도를 빠르게 만들기는 일반적으로 반비례한다.
- 상황
    - 순차 프로세스를 빠르게 실행
    - 멀터 코어 아키텍처
    - 클러스터
    - GPU
    - 이상적인 시스템: 주어진 예산안에서 필요한 만큼의 프로세스를 사용할 수 있는 확장 가능한 시스템
- 병목현상
    - 병의 목 부분처럼 넓은 길이 갑자기 좁아짐으로써 대표적으로 교통 정체 현상, 컴퓨터 성능 저하 현상을 예로 들 수 있습니다.

- CPU 성능 관련 문제
- 데이터 전송
- 메모리 관련 해법

    
## 0. KEYWORD
- 사이썬(Cython)
- Numpy
- PyPy
- JIT(just-in-time) 컴파일러
- 비동기 I/O


## 1. 고성능 파이썬 이해하기
- 컴퓨터 아키텍처를 구성하는 요소
- 일반적으로 사용되는 몇가지 컴퓨터 아키텍처
- 파이썬에서 컴퓨터 아키텍처를 추상화하는 방법
- 고성능 파이썬 코드를 작성할 때 넘어야 할 장벽
- 뛰어난 성과를 거두는 프로그래머가 되는데 필요한 전략

### 고성능 프로그래밍
- 부가비용을 줄임(효과적인 코드 작성)
- 각 과정을 더 의미있는 방법(더 적합한 알고리즘)으로 변경

### 컴퓨터 기본 시스템
- 연산장치
    - CPU(주 연산 장치)
        - L1, L2, L3, L4 캐시
        - 입력된 bit를 다른 bit로 변환 하거나 프로세스의 상태를 변환시킴
    - GPU(보조 연산 장치)
        - 고유의 병렬적인 특성이 장점
    - 연산측정: IPC(instructions per cycle; 한사이클에 처리가능한 연산 개수)
        - 인텔 코어 시리즈: IPC 높음, 클럭속도 느림
        - 펜티엄4: IPC 낮음, 클럭속도 빠름
        - GPU: IPC 높음, 클럭속도 빠름
    - 클럭속도: 초당 연산량 증가 -> 프로그램 속도 향상
    - IPC: 벡터화 수준이 증가 -> 처리성능 상승 
        - 벡터화: 여러데이터를 입력받아 한번에 처리할 때 발생(SIMD; single instruction  multiple data)
    - 연산속도 향상
        - 동시적인 다중 스레딩
          - 하이퍼 스레딩: 운영체제에 가상의 두번째 cpu 인식, 단일 cpu를 두 스레드를 번갈아 가면서 실행 -> 30%성능 향상
        - 비순차적 명령어 처리
          - 프로그램 실행 과정에서 이전 작업의 결과에 영향을 받지 않는 부분을 찾아내서 두 작업을 순서와 관계없이 실행하거나 동시에 실행
          - 한 명령이 메모리에서 데이터를 가져오는 등의 이유로 대기하는 동안 다른 명령을 실행함으로써 사용가능한 자원을 최대한 활용할 수 있게 한다.
        - **멀티 코어 아키텍처**
          - 실행 유닛 하나에 cpu를 여러개 두어 처리량 향상
        - 암달의 법칙: 여러 나눌 수 있는 작업들을 나눠서 해도 무조건 시간이 줄어들지는 않음
            - 조사시간 1분, 조사원 1명, 100명의 인원, 조사원이 100명이 넘어가도 시간이 줄어들지 않음
- 저장장치(ram, disk)  
  - bit를 저장, bit는 변수, 픽셀 등을 나타냄
  - 임의접근(random access): 조금씩 자주읽음
  - 순차접근(sequential): 한꺼번에 많이 읽음
  - 읽기/쓰기, 레이턴시(latency): 장치가 데이터를 찾기까지 걸리는 시간
  - L1/L2캐시: CPU로 전달하는 데이터는 항상 이 캐시를 거쳐간다. MB단위로 용량이 아주 작음   

- 연결장치(bus)
  - FSB: RAM과 L1/L2캐시를 연결한다. 초당 10GB 데이터 전송 가능
  - GPU는 일반적으로 PCI버스로 연결되며 아주 느리다. 이기종 컴퓨터는 FSB로 연결되어 있음
  - 네트워크(매우 느림): 초당 0KB ~ 1GB
  - 전송속도 측정
    - 폭(witdth): 데이터 양
    - 주파수(frequency): 초당 전송할 수 있는 수
    - 물리적인 선의 길이가 짧을 수록 빠름
    - 연결하는 선의 수가 많아지면 버스폭이 넓어짐
    
## 2. 병목지점 찾기
- 프로파일링으로 병목지점을 찾아 최소한의 노력으로 성능을 최대한 끌어낼 수 있음
    - 프로파일링 
        - 시스템의 어느 부분이 느린지, 어디서 RAM을 많이 쓰는지, 디스크 I/O, 네트워크 I/O를 과도하게 발생시키는 부분이 어딘지 확인        
        - 측정 가능한 자원은 모두 프로파일할 수 있음(CPU시간, 메모리 사용량, 네트워크 대역폭, 디스크 I/O)
        - 프로파일링 기법(단위 테스트 실시)
            - 시간 측정
                - IPython %timeit 매직 명령어
                - time.time()
                - 데커레이터(decorator)
            - 어떤 함수가 오래 걸리는지             
                - cProfile
            - 선택한 함수를 한줄씩 프로파일
                - line_profiler: 몇줄 실행했는지, 총 소요시간은 얼마인지 검사, 어느부분이 왜 느린지 알 수 있음.
            - CPU 실행된 명령어 수, CPU캐시가 얼마나 효율적으로 활용
                - perf stat
                - 매트릭스 연삭을 튜닝하는 고급 기법에 활용됨.
            - 프로세스 내부를 들어다 볼 수 있는 도구
                - py-spy
            - RAM 사용량 높은 이유
                - memory_profiler
        - 바이트코드: 파이썬 내부를 더 잘 이해할 수 있음
        - 파이썬 스택 기반 가상머신: 특정 코딩 습관이 코드를 느리게 함.
    
### 줄리아 집합
- RAM과 CPU를 많이 잡아먹는 함수, 비선형적인 특징을 가짐

    
          