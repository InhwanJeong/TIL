Linux
=====

Command
-------

## ls : 현재 폴더의 내용물을 보여준다

- ls -al : 현재 폴더의 내용 + 권한, 용량, 수정날짜를 보여준다.   
- ls -l 파일 : 특정 파일의 권한을 보여준다.           

**#접근권한 -------**

파일타입 | private | protected | public
--- | --- | --- | ---
d | rwx  | rwx  | rwx

파일 타입 | 내용
--- | ---
Nothing(-) | 일반 파일
d | 디렉터리
p | Named pipe
s | 소켓
b, c | 디바이스 파일

- r : read, 읽기 권한
- w : write, 쓰기 권한
- x : execution, 실행 권한                  
-> ex) -rwxr-x--x (일반파일이며,나는 읽고 쓰고 실행, 내 그룹은 읽고 실행, 그외는 실행만 가능)                 

#### 접근 권한 변경
- chmod : 파일 모드 변경
```
$ chmod [options] mode file
$ chmod [references][operator][modes] file
```

레퍼런스 | 클래스 | 설명
--- | --- | ---
u | 사용자 | 파일의 소유자
g | 그룹 | 그 파일의 그룹 멤버인 사용자
o | 다른사람들 | 그외 사용자
a | 모든 사람 | ugo를 모두 포함

연산자 | 설명
--- | ---
(+) | 지정된 모드들은 지정된 클래스에 더한다 (해당 레퍼런스 기능 추가)
(-) | 지정된 모드들은 지정된 클래스에 지운다 (해당 레퍼런스 기능 제거)
(=) | 지정된 클래스들을 위해서 지정된 모드들이 정확한 모드들로 만들어지게 된다

모드 | 이름 | 설명
--- |--- | ---
r | 읽기(read) | 파일을 읽거나 디렉터리 안 내용물의 리스트를 보여준다
w | 쓰기(write) | 파일이나 디렉터리에 쓴다
x | 실행(excute) | 파일을 실행하거나 디렉터리 트리로 되돌아간다

명령 | 설명
--- | ---
chmod +r file |모두에 대해 읽기를 추가한다
chmod -x file |모두에 대해 실행 허가를 제거한다
chmod u=rw,go= file |파일의 읽기와 쓰기를 그 파일의 소유자에게만 설정하고 그룹이나 다른 사람들에게 설정된 모든 허가를 지운다
chmod +rw file |모두가 읽고 쓸 수 있도록 file이라는 파일의 허가들을 바꾼다
chmod -R u+w,go-w docs/ | 사용자에게는 쓰기를 추가하고 다른 모든 사람들에게는 쓰기를 제거하기 위해서 docs라는 디렉터리와 그 안의 모든 내용물에 대한 허가들을 바꾼다.
chmod 0 file|모두의 모든 허가를 지운다
chmod 666 file |그 사용자, 그 그룹이나 다른 모든 이에 대해서 쓰기나 읽기 권한을 설정한다
chmod 0755 file |u=rwx (4+2+1)나 go=rx (4+1 & 4+1)와 같다. 0는 어떤 특별한 모드들도 지정하지 않는다.
chmod 4755 file |4은 사용자 ID 설정을 지정하고 나머지는 u=rwx (4+2+1)나 go=rx (4+1 & 4+1)와 동일하다
chmod -R u+rwX,g-rwx,o-rwx directory |소유자 디렉터리에 대한 rwx(읽기, 쓰기, 실행)을, 소유자 파일들에 대해서는 rw(읽기, 쓰기)를, 그룹이나 다른 이들에 대해서는 ---를 설정하기 위해서 디렉터리 트리를 설정한다.
chmod -R a-x+X directory |디렉터리 트리 안에 있는 모든 파일들에 대한 실행 허가를 제거한다. 반면 디렉터리 열람은 허용한다. 


## alias : 별명을 만들어 명령어를 간단하게 실행
- 영구 등록방법
```
$ vi ~./bashrc #vi 편집기로 추가할 내용 추가
$ source ~/.bashrc #vi 편집기 종료 후 입력
```
- alias 별명=''   $ alias 1='cd /opt/lampstack-7.1.19-0;sudo ./manager-linux-x64.run'


## cd : 폴더 위치를 바꿀때 사용한다.

- cd / : 최상위 폴더로 이동
- cd  or cd ~  : 바탕화면 다운로드 등 기본 폴더가 있는 곳으로 이동
- cd 폴더명 : 현재 폴더안에 있는 폴더로 이동
- cd 폴더명/폴더명/폴더명 ... : 해당 폴더로 이동
- cd..   : 상위 폴더로 이동

## man(manual) 명령어
- 9개의 섹션으로 나뉘어 져있다.
- man + 명령어로 명령어의 설명을 볼 수 있다.
- man -k translate로 한줄로 요약된 설명서를 볼 수 있다.
- manpath로 man의 기본경로를 알 수 있다.

## 파일, 패키지 찾기 기능
- which : 해당 프로그램이 깔려있는지 확인
- whereis : which 보다 더 넓은 범위 탐색
- locate : 하드디스크에 있는 모든 파일 탐색

## 폴더 생성 삭제

- mkdir 폴더명  : 현재 폴더에서 폴더 생성
- rmdir 폴더명  : 현재 폴더에서 폴더 삭제        
- rm - rf 폴더명 : 폴더 삭제
- mv 폴더명 위치 : 폴더 이동
- mv 폴더명1 폴더명2 :  1 -> 2로 이름변경

## 파일 생성 삭제

1-1.touch 파일명 : 현재 폴더에 파일생성     
1-2.cat>파일명   : 현재 폴더에 파일생성과 동시에 내용물 초기화        
1-3.vi 파일명    : visual display editor을 실행 시키며 내용물을 작성,수정을 할 수 있다.       
1-4.gedit 파일명 : GUI 형태의 파일 생성       

- $ gedit test.c       
- $ gcc -o test test.c     
- $ ./test     

2.rm 파일명 : 현재 폴더에 파일 삭제

3.mv 파일명 위치 : 파일 이동

4.mv 파일명1 파일명2 : 1 -> 2로 이름변경

## 그 외 기능
- clear : 화면청소기능



# System Administration 

## Where to start

### 1.1 시스템 관리자의 개인적인 의무
- 계정 프로비저닝
- 하드웨어 추가 및 제가
- 백업 수행하기
- 소프트웨어를 설치하고 업그레이드
- 시스템을 모니터링
- 문제 해결
- 로컬 문서 유지보수
- 보안을 철저히 모니터링
- 소방업무(고객의 급한일 처리)

### 1.2 사전 지식을 요구한다.
- 유닉스와 리눅스에 대한 사전지식을 요구
- 스크립트 작성으로 명령 쉘과 텍스트 편집 능력에 능숙해야한다.
- 편집기 gedit, vi, emacs를 사용한다.(ms word, open office는 쓸모없다.)
- 프로그래밍언어로는 perl과 파이썬을 권장한다.

### 1.3 유닉스와 리눅스 간 마찰
- 두 운영체제는 비슷한 운영체제이다.
- 이 책에서는 두 운영체제 모두 사용할 예정이다.
- 서로간의 마찰이 많다.

### 1.4 리눅스 배포판
- 모든 리눅스는 동일한 커널계열을 공유하지만 보조자료는 상당히 다르다.
- 디비안, 레드햇과 같이 SUSE기반이 우세하다.
- 배포판 선택에 있어 중요한 4가지 사항
1. 이 배포판은 5년 후에 출시 되는가?
2. 이 배포판은 보안 패치가 추가 될 예정인가?
3. 업데이트 된 소프트웨어를 즉시 공개하는가?
4. 문제 발생시 공급 업체가 나에게 이야기 해 주는가?

- 리눅스 선택에 있어 꼭 많이 사용되는 것을 사용하지 않아도 된다.

### 1.5 이책에 사용된 시스템 예제
- 가급적 모든 리눅스 예제가 들어갈 예정이다.
- 특별한 경우 해당 리눅스로고가 들어갈 예정이다.

### 1.6 시스템- 특정관리 도구
- 다양한 도구와 제어판이 있다.
- 초보에게 유용하지만 불완전하다.
- 시각적 도구는 문제 추적과 수정에 도움이 안된다.
- 수동 구성이 더 빠르고 유연하며 안정적이다. 그리고 스크립트 구성이 쉽다.

### 1.7 표기법과 표기규칙
- 파일이름, 명령, 명령에 대한 문자인수는 굵게 표시되어있다.
- []는 추가적인 옵션, {}는 항목 중 선택, ...은 되풀이 되는것을 의미한다.
- *는 0개나 그 이상과 매치된다.
- ?는 한 문자랑 매치된다.
- ~는 현재 사용자의 홈 디렉터리를 의미한다.

### 1.8 단위
- 소문자 b : 비트 , 대문자 B : 바이트
- RAM은 항상 2의 배수로 표기, 네트워크 대역폭은 항상 10의 배수로 표기
- 저장공간은 10의 제곱으로 표기 -> 실제론 2의 배수

### 1.9 Man 페이지와 다른 문서
- Manual페이지 인데 man 명령어로 실행되서 Man페이지 라고도 불린다.
- 일반적으로 소프트웨어 설치시 패키지에 함께 제공 된다.
- Man 페이지는 개별명령, 드라이버, 파일 형식, 라이브러리 루틴에 관한 설명이 있다.
- 모든 메뉴얼은 섹션별로 나뉜다.
- man -k로 한줄로 요약된 메뉴얼 페이지를 출력할 수 있다.
- nroff(new roff)는 멘페이지 텍스트를 포멧하는데 사용한다.
- manpath라는 명령을 통해 현재 기본경로를 찾을 수 있다.

### 1.10 기타 공인문서
- man 페이지는 공식 문서의 일부분이고 나머지는 웹상에 흩어져있다.
- 주요업체는 자체 문서프로젝트를 보유하고 있으며 요즘은 인터넷에서 무료로 다운로드 할 수 있다.
- 구글에 검색하면 좋지않은것 부터 좋은 파일들이 많이 있다.

### 1.11 기타 정보 출처
- 인터넷 블로그, 포럼등에 많은 자료가 있다.
- 구글은 시스템관리자의 최고의 친구이다. 구글에 버릇 들이자.

### 1.12 소프트웨어를 찾아서 설치하는 방법
- 소프트웨어가 설치되어 있는지 확인
```
기본 : which gcc
확장 : whereis gcc
모든 유형의 파일 : locate gcc
```
- 새 소프트웨어 추가        
-새 소프트웨어 추가를 위해선 패키지의 정식 명칭을 알아야 한다.        
-각 운영체제별 설치 방법
```
Ubuntu   : apt-get install wget
SUSE    : yast --install wget
Red hat : yum install wget
Solaris : /opt/csw/bin/pkgutil --install wget
HP-us   : gunzip /tmp/wget-1.11.4-hppa-11.31dept.gz
          swunstall -s /tmp/wget-1.11.4-hppa-11.31.depot wegt
```
- swinstall 명령 줄의 패키지 저장소는 /로 시작하는 경로를 지정해주어야 한다. 그렇지 않으면 네트워크에서 파일을 찾는다.
- 소스코드에서 소프트웨어 빌드하기     
-configure /make /make 설치순서는 대다수의 유닉스와 리눅스에서 공통적으로 사용.      
-configure옵션을 사용하면 설치되지 않은 다른 라이브러리에 의존하는 wget기능을 생략한다.     
-만약 실생활에서 전제조건을 설치하기를 원한다면 configure --help를 사용해 보자.

9.Periodic Processes(주기적 프로세스)
===

- 사람이 개입하지 않고 자동으로 스크립트나 명령을 실행하는 것
- 예시 1) 스크립트가 30분마다 네트워크 라우터나 스위치가 올바르게 작동하는지 확인하고 문제가 발생시 이메일로 문제사항을 발신하도록 하는 것
- 예시 2) 매월 초 백업 자료를 받고 싶을 때
- 예시 3) 새벽에 늦은 시간에 특정 일을 수행해야 할 때

##  9.1 CRON : 스케쥴 명령어
- 크론 데몬은 결정된 일정에 따라 명령을 실행하기 위한 도구이다.(시스템 부팅시 시작되며 시스템 작동시 계속 실행된다.)
  - 그러므로 항상 켜져있는 서버같은 시스템에 굉장히 효율적인 명령어다.
- 쉘에서 수동으로하는 거의 모든것이 cron에 의해 자동으로 수행할 수 있다.
- crontab(cron table) : 크론 설정파일
  - var/spool/cron/crontab에 저장
    - crontab에 접근하기 위해서는 su 명령어를통해 루트인 상태로만 가능하다.

## 9.2 CRONTAB파일의 형식
- 크론탭 파일은 비슷한 형식을 공유한다.
  - 주석은 첫번째 열에 #기호와 함께 도입된다.
  - 각 행은 6개의 필드를 포함하며 하나의 명령을 나타낸다.

```
# * * * * * /home/inan
# 위 명령어는 실행 X

* * * * * mkdir /home/inan/test
# 위 명령어는 1분마다 /home/inan/에 test라는 디렉터리를 생성

20 1 * * * find /tmp -atime +3 -type f -exec rm -f {} ';'
# 위 명령어는 매일 오전 1시 20분마다 /tmp 디렉터리에서 3일동안 엑세스 하지 않은 모든 파일을 제거하라는 명령어 이다.
```

| 필드 | 의미     | 범위 |
| :------------- | :------------- | --- |
| 첫번째 | 분 | 0-59
| 두번째 | 시 | 0-23
| 세번째 | 일 | 0-31
| 네번째 | 월 | 1-12
| 다섯번째 | 요일| 0-6(0:일요일 6: 토요일)
| 여섯번째 | 명령어 | 실행할 명령을 한줄로 쓴다.

## 9.3 CRONTAB 관리
- crontab -l : crontab의 설정 내용을 조회
- crontab -e : crontab의 설정 내용 수정
- crontab -r : crontab의 설정 내용 삭제(var/spool/cron 디렉터리 안의 내용 삭제)
- 대부분의 시스템에서 엑세스 제어는 cron이 아니라 crontab에 의해 구현된다.

## 9.4 리눅스와 빅시-크론
- 리눅스 배포판에 포함된 크론 중 폴 빅시의 이름을 따서 ISC cron 또는 vixie-cron으로 알려진 버전이 있는데 이 버전은 현대적으로 재작성되어 더 추가적인 기능을 제공한다.
  - 가장 큰 차이점은 사용자 별로 crontab을 가지고 있다는 점이다.

## 9.5 크론의 공통된 사용 팁
- 많은 기본 업무들이 크론을 사용하기 적합하다.
- 크론탭의 기본 항목을 비활성화 할때 지우지말고 주석처리하는 것이 좋다.

#### 간단한 알리미
- 생일, 업무, 진행중인 업무에 대해서 간단한 알리미 기능을 추가 할 수 있다.
- 필요한 경우 전자메일로 중요사항을 전달 할 수 있다.

#### 파일 시스템 청소
- 쓰레기 파일들(오랫동안 사용하지 않거나 충돌이 일어난 프로그램을 정리 해주는 기능이 있다.

#### 구성파일의 네트워크 배포
- 특정사항을 메일로 배포할때 유용

#### 로그순환
- 로그 순환은 반복적이고 규칙적이기 때문에 크론을 사용하면 유용하다.

13.Drivers and the kernel
===
- 커널
  - 운영체제의 핵심 프로그램이다.
  - 시스템의 모든 것을 통제한다. -> 애플리케이션과 하드웨어를 연결

## 13.1 kernel adaptation(커널 적응)
- 유닉스 기반의 운영체제들은 모놀리식 커널로 작동한다.
  - 모놀리식 커널(단일형 커널): 운영체제의 일반적인 기능(입출력, 네트워크, 장치) 등의 기능을 커널과 동일한 메모리 공간에 적재, 실행하는 기법
  - 마이크로 커널: 핵심적인 기능만 남긴 최소한의 커널

- 드라이버, 파일시스템,호출은 모듈로 구성 -> 불필요한것 제거 가능
- 커널은 여러가지 방법으로 시스템 하드웨어를 배운다.
  - 사용자가 명시적으로 알려준다.
  - 부팅시 또는 동적으로 여러 장치에 대해 예측한다. -> USB 장치(메모리 스틱, 디지털 카메라, 프린터 등)에서 가장 일반적인 방법입니다.

- 리눅스 빌드 디렉토리: /usr/src/linux
- 커널 : /vmlinuz or /boot/vmlinuz

## 13.2 Drivers and Device Files(드라이버와 장치파일)
- 장치 드라이버
  - 특정 유형 하드웨어와 상호작용을 관리하는 프로그램
  - 대부분의 장치드라이버는 커널의 일부이다.
  - 커널과 사용자 모두 사용이 가능하다.
  - /dev: 사용자수준 엑세스 가능한 디렉토리 -> 대부분의 장치파일이 존재하는 곳
  - 하드웨어 발전이 빨라 하드웨어 사용을 위해 드라이버를 추가해야할 필요도 있을 것이다.

#### 장치 파일과 장치 번호
- 커널은 장치 번호를 사용하여 장치 파일 참조를 해당 드라이버에 매핑합니다.
  - 메이저 번호: 연결된 드라이버(장치 유형)을 식별한다.
  - 마이너(장치) 번호: 해당 장치의 특정 인스턴스를 수행해야하는지 판단

~~~
linux$ ls -l /dev/sda
brw-rw---- 1 root disk 8, 0 Jul 13 01:38 /dev/sda
// 메이저 번호: 8 마이너 번호: 0
~~~

#### 장치파일 생성
~~~
mknod filename type major minor
// 타입 : 문자 장치의 경우 c 또는 블록 장치의 경우 b
// 메이저,마이너 번호: 드라이버 설명서를 참조하면서 적절한 번호 부여
~~~

- udev 시스템
  - 장차파일 생성,제거를 동적으로 관리
  - 장치의 상태변경과 관련된 명령을 커널과 주고받음(자세한건 책 뒤에)
  - 이 시스템 덕에 리눅스를 할때 mknod 명령어를 통해 수동으로 관리 할 필요가 없다

#### 장치의 이름 지정 규칙
- tty : 직렬 장치 파일 이름 + 장치가 연결된 인터페이스 번호


## 13.3 Linux kernel configuration(리눅스 커널 구성)
- 4가지 커널 기본 구성
  - 조정 가능한(동적) 커널 구성 매개 변수 수정
  - 커널을 처음부터 빌드하라. (이것은 실제로 커널을 컴파일하는 것을 의미한다. 소스 코드, 수정 및 추가 가능)
  - 기존 드라이버 및 모듈을 기존 커널에 즉시로드
  - 커널 로더를 통해 부팅시 운영 지침을 제공

#### 리눅스 커널 매개변수 튜닝
- 커널의 많은 모듈과 드라이버는 크기가 맞지 않는다. -> 내부 테이블크기 또는 동작을 제어 가능
- proc 시스템을 통해 엑세스 가능
  - /proc/sys의 특수 파일을 통해 커널 옵션을 확인하고 변경할 수 있다.

~~~
linux$ cat /proc/sys/fs/file-max
34916
linux$ sudo sh -c "echo 32768 > /proc/sys/fs/file-max"
// 동시에 열수있는 파일의 갯수
// 이외에도 굉장히 많은 매개변수 존재
~~~

- sysctl 명령
  - 영구적인 매개변수값 변경
  - etc/sysctl.conf는 부팅 할 때 읽히며 그 내용은 초기 (사용자 정의) 매개 변수 값을 설정하는 데 사용된다.

~~~
linux$ sudo sysctl net.ipv4.ip_forward=0
~~~

- 커널을 빌드 해줘야 할 때도 있다.
- 완전히 고장나지 않았다면 고치지마라.

- 커널 옵션 구성
  - 대부분의 배포판은 usr/src에 커널 소스파일을 설치
  - 커널 구성 프로세스는 커널 원본 루트에 있는 .config파일을 중심으로 진행된다.
  - **.config의 위치** -> 쉘이용(빌드 디렉토리에 위치), 일반적인 방법 컴파일(현제 커널 위치에 생성) -> 이 차이로 설정이 저장 되고 안되고 문제가 발생

#### 커널 바이너리 빌딩
- 적절한 .config 파일을 설정 -> Linux 커널 구성 프로세스의 가장 중요한 부분, 파일을 완성 된 커널로 바꾸려면 더 많은 작업을 수행해야한다.

~~~
• 디렉토리 (cd)를 커널 소스 디렉토리의 최상위 레벨로 변경합니다.
• make xconfig, make gconfig 또는 make menuconfig를 실행하십시오.
• make dep를 실행합니다 (커널 2.6.x 이상에서는 필요하지 않음).
• make make clean을 실행합니다.
• make를 실행합니다.
• make modules_install을 실행합니다.
• arch / i386 / boot / bzImage를 / boot / vmlinuz에 복사하십시오.
• arch / i386 / boot / System.map을 /boot/System.map에 복사하십시오.
• /boot/grub/grub.conf에 새 커널의 구성 줄을 추가합니다.
// 주의사항 : make clean단계는 필수는 아니지만, 이 단계를 생략하면 문제가 발생할 수도 있다.
~~~

#### 리눅스 장치 드라이버 추가
- 3가지 일반적인 형태
  - 특정 커널에 대한 패치
    ~~~
    linux# cd path_to_kernel_src; patch -p1 < patch_file
    ~~~
  - 적재 가능한 모듈

  - 드라이버를 설치하는 설치 스크립트 또는 패키지 -> 가장 이상적

## 13.7 Loadable kernel modules(LKM)
- LKM은 모든 유닉스 운영체제가 사용한다.
- LKM을 통해 다른 장치나 커널 서비스가 운영중에도 커널에 링크되거나 제거할 수 있다. -> 매우편리 but 100% 안전하지 않다.(커널 패닉 발생)
- LKM은 일반적으로 /lib/modules/version에 저장된다. (version은 $uname -r 했을 때 반환되는 이름: 4.4.0-21-generics)
- lsmod 명령을 사용하여 LKM을 검사 할 수 있습니다.

~~~
linux$ sudo /sbin/lsmod

Module       Size   Used by
ipmi_devintf 13064  2

linux$ sudo insmod /path/to/snarf.ko
// insmod로 수동 설치

linux$ rmmod snarf
// rmmod로 수동 제거

modprobe: 반자동 프로그램
~~~

## 13.8 Linux UDEV for fun and profit
- 장치 파일 -> 세월을 걸쳐 어렵고 복잡해짐 -> UDEV 등장
  - sysfs 기본 기술 이해 필요
  - udevadm 명령사용 이해

#### 리눅스 sysfs
- 시스템의 사용 가능한 장치, 구성 및 상태에 대한 정보를 상세하게 제공
- /sys 디렉토리를 탐색하여 장치가 사용하는 IRQ(인터럽트 요청)와 대기중인 블록을 알 수 있다.
- /sys의 서브 디렉토리

| 디렉토리     | 설명    |
| :------------- | :------------- |
| block       | 하드 디스크와 같은 블록 장치에 대한 정보  |
| bus | 커널에 알려진 버스 : PCI-E, SCSI, USB 및 기타|
|class | 기능적 유형의 장치 (예 : 사운드 및 그래픽 카드, 입력 장치 및 네트워크 인터페이스)별로 구성된 트리|
| dev  | 문자 및 블록 장치간에 장치 정보 분리 |
| devices| 발견 된 모든 장치의 알기 쉬운 표현|
| firmware| ACPI와 같은 플랫폼 특정 하위 시스템과의 인터페이스|
|fs | 커널이 아는 일부 파일 시스템 (전부는 아님) 용 디렉토리|
| kernel| 캐시 및 가상 메모리 상태와 같은 커널 내부 구조|
| module| 내부 구조 커널에 의해로드 된 동적 모듈|
|power | 시스템의 전원 상태에 대한 몇 가지 세부 사항; 주로 미사용|

- 장치에 대한 정보가 전혀 없다면 Proc에서 찾을 수 있다
  - 하지만 시간이 지남에 따라 /sys로 이동한다.

#### udevadm을 통한 장치 탐색

~~~
linux$ udevadm info -a -n sdb
// info, trigger, settle, control, monitor, test, 총 6가지 인수가 들어갈 수 있다.
~~~

#### 규칙 및 영구이름 만들기
- 저장 위치
  - 기본 규칙: /lib/udev/rules.d
  - 로컬 규칙: /etc/udev/rules.d

#### lsusb 명렁어
- usb버스를 직접 검사 가능
~~~
ubuntu$ lsusb
Bus 001 Device 007: ID 1307:0163 Transcend, Inc. USB Flash Drive
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
~~~
